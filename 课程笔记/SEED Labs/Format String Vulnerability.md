![](https://raw.githubusercontent.com/lc1838228782/pics/master/img/formatpara.png)

##  crash of program

```c
printf ("%s%s%s%s%s%s%s%s%s%s%s%s");  // %n also works
```

## viewing the stack

```c
printf ("%08x.%08x.%08x.%08x.%08x\n");
```

###  viewing memory at any location

`printf("0xdeadbeef...%s")`

## Overwriting of arbitrary memory

### Exploitation - similar to common buffer overflows

QPOP2.53, bftpd

```c
{
    char outbuf[512];
    char buffer[512];
    
    sprintf(buffer, "ERR Wrong command: %400s", user);
    sprintf(outbuf, buffer);
}
```

Circumvent the "%400s": `"%497d\x3c\xd3\xff\xbf<nops><shellcode>"  `

### Exploitation - through pure format strings

wu-ftpd 2.6.0

```c
{
    char buffer[512];
    
    snprintf(buffer, sizeof(buffer), user);
    buffer[sizeof(buffer) - 1] = '\0';
}
```

`%nu` control the number to write

And, on most CISC architectures it is possible to write to unaligned arbitrary addresses.   

![](https://raw.githubusercontent.com/lc1838228782/pics/master/img/format_string_overwrite.jpg)

## Variations of Exploitation

### Short Write

`%hn`

### Stack Popping

- `%u` 2 bytes pops 4 bytes. 1:2

- `%f` 2 bytes pops 8bytes. There may be a division by zero crash. `%.f`only print the integer part could bypass it.

- Under BSD derivates and IRIX, it is possible to abuse the ‘\*’-qualifier for our purposes. It is used to dynamically supply the length of the output a format parameter will produce. `%*d`  retrieves the length of the output dynamically  from the parameter. 1:4. 

  The length can be controled by `%********10d`. The previous `*` won't work.

### Direct Parameter Access

`%n$`



## Ref

https://cs155.stanford.edu/papers/formatstring-1.2.pdf