# Lab6 调度器

## 理论

### 进程状态

**进程的生命周期**

- 进程首先在 cpu 初始化或者 sys_fork 的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入 uninit态(在proc.c 中 alloc_proc)。
- 当进程完全完成初始化之后，该进程转为runnable态。
- 当到达调度点时，由调度器 sched_class 根据运行队列rq的内容来判断一个进程是否应该被运行，即把处于runnable态的进程转换成running状态，从而占用CPU执行。
- running态的进程通过wait等系统调用被阻塞，进入sleeping态。
- sleeping态的进程被wakeup变成runnable态的进程。
- running态的进程主动 exit 变成zombie态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为unused。
- 所有从runnable态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。

### 内核抢占点

用户进程具有可抢占性(preemptive)，ucore内核执行是不可抢占的(non-preemptive)。

但并不是所有情况下ucore内核都不可抢占，有以下例外：

1. 进行同步互斥操作，比如争抢一个信号量、锁（lab7中会详细分析）；
2. 进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，ucore会调用shcedule让其他就绪进程执行。

这几种情况其实都是由于当前进程所需的某个资源（也可称为事件）无法得到满足，无法继续执行下去，从而不得不主动放弃对CPU的控制权。如果参照**用户进程任何位置**都可被内核打断并放弃CPU控制权的情况，这些在**内核**中放弃CPU控制权的执行地点是“**固定**”而不是“任意”的，不能体现内核任意位置都可抢占性的特点。

### 调度算法

先来先服务算法、短进程优先算法、最高响应比优先算法、时间片轮转算法、多级反馈队列算法、贡品共享调度算法