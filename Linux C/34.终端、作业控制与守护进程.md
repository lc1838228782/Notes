## 1 终端

每个进程有一个控制终端，每个进程的标准输入、标准输出和标准错误输出都指向控制终端。

每个进程都可以访问`/dev/tty`反问它的控制终端，这是一个通用接口，事实上每个终端设备对应一个不同的设备文件。

### 终端登录过程

**图 34.1. 终端设备模块**

![终端设备模块](https://akaedu.github.io/book/images/jobs.terminalmodule.png)

**线路规程(line discipline)**像一个过滤器，对于某些特殊字符并不是让它直接通过，而是做特殊处理，比如在键盘上按下Ctrl-Z，对应的字符并不会被用户程序的`read`读到，而是被线路规程截获，解释成`SIGTSTP`信号发给前台进程，通常会使该进程停止。线路规程应该过滤哪些字符和做哪些特殊处理是可以配置的。

终端设备有输入和输出队列缓冲区，如下图所示。

**图 34.2. 终端缓冲**

![终端缓冲](https://akaedu.github.io/book/images/jobs.terminalqueue.png)

1、系统启动时，`init`进程根据配置文件`/etc/inittab`确定需要打开哪些终端。例如配置文件中有这样一行：

```
1:2345:respawn:/sbin/getty 9600 tty1
```

和`/etc/passwd`类似，每个字段用`:`号隔开。开头的1是这一行配置的id，通常要和`tty`的后缀一致，配置`tty2`的那一行id就应该是2。第二个字段2345表示运行级别2~5都执行这个配置。最后一个字段`/sbin/getty 9600 tty1`是`init`进程要`fork`/`exec`的命令，打开终端`/dev/tty1`，波特率是9600（波特率只对串口和Modem终端有意义），然后提示用户输入帐号。中间的`respawn`字段表示`init`进程会监视`getty`进程的运行状态，一旦该进程终止，`init`会再次`fork`/`exec`这个命令，所以我们从终端退出登录后会再次提示输入帐号。

有些新的Linux发行版已经不用`/etc/inittab`这个配置文件了，例如Ubuntu用`/etc/event.d`目录下的配置文件来配置`init`。

2、`getty`根据命令行参数打开终端设备作为它的控制终端，把文件描述符0、1、2都指向控制终端，然后提示用户输入帐号。用户输入帐号之后，`getty`的任务就完成了，它再执行`login`程序：

```
execle("/bin/login", "login", "-p", username, NULL, envp);
```

3、`login`程序提示用户输入密码（输入密码期间关闭终端的回显），然后验证帐号密码的正确性。如果密码不正确，`login`进程终止，`init`会重新`fork`/`exec`一个`getty`进程。如果密码正确，`login`程序设置一些环境变量，设置当前工作目录为该用户的主目录，然后执行Shell：

```
execl("/bin/bash", "-bash", NULL);
```

注意`argv[0]`参数的程序名前面加了一个`-`，这样`bash`就知道自己是作为登录Shell启动的，执行登录Shell的启动脚本。从`getty`开始`exec`到`login`，再`exec`到`bash`，其实都是同一个进程，因此控制终端没变，文件描述符0、1、2也仍然指向控制终端。由于`fork`会复制PCB信息，所以由Shell启动的其它进程也都是如此。

### 网络登录过程

**图 34.3. 伪终端**

![伪终端](https://akaedu.github.io/book/images/jobs.pseudotty.png)

1. 用户通过`telnet`客户端连接服务器。如果服务器配置为独立（Standalone）模式，则在服务器监听连接请求是一个`telnetd`进程，它`fork`出一个`telnetd`子进程来服务客户端，父进程仍监听其它连接请求。

   另外一种可能是服务器端由系统服务程序`inetd`或`xinetd`监听连接请求，`inetd`称为Internet Super-Server，它监听系统中的多个网络服务端口，如果连接请求的端口号和`telnet`服务端口号一致，则`fork`/`exec`一个`telnetd`子进程来服务客户端。`xinetd`是`inetd`的升级版本，配置更为灵活。

2. `telnetd`子进程打开一个伪终端设备，然后再经过`fork`一分为二：父进程操作伪终端主设备，子进程将伪终端从设备作为它的控制终端，并且将文件描述符0、1、2指向控制终端，二者通过伪终端通信，父进程还负责和`telnet`客户端通信，而子进程负责用户的登录过程，提示输入帐号，然后调用`exec`变成`login`进程，提示输入密码，然后调用`exec`变成Shell进程。这个Shell进程认为自己的控制终端是伪终端从设备，伪终端主设备可以看作键盘显示器等硬件，而操作这个伪终端的“用户”就是父进程`telnetd`。

3. 当用户输入命令时，`telnet`客户端将用户输入的字符通过网络发给`telnetd`服务器，由`telnetd`服务器代表用户将这些字符输入伪终端。Shell进程并不知道自己连接的是伪终端而不是真正的键盘显示器，也不知道操作终端的“用户”其实是`telnetd`服务器而不是真正的用户。Shell仍然解释执行命令，将标准输出和标准错误输出写到终端设备，这些数据最终由`telnetd`服务器发回给`telnet`客户端，然后显示给用户看。

每按一个键都要在网络上走个来回！

## 2 作业控制

**图 34.4. Session与进程组**

![Session与进程组](https://akaedu.github.io/book/images/jobs.pg.png)

## 3 守护进程(daemon)

